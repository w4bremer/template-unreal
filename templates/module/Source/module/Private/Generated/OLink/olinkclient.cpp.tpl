{{- /* Copyright Epic Games, Inc. All Rights Reserved */ -}}
/**{{ template "copyright" }}*/
{{- $ModuleName := Camel .Module.Name}}
{{- $IfaceName := Camel .Interface.Name }}
{{- $Category := printf "ApiGear|%s|%s" $ModuleName $IfaceName }}
{{- $DisplayName := printf "%s%s" $ModuleName $IfaceName }}
{{- $Class := printf "U%sOLinkClient" $DisplayName}}
{{- $abstractclass := printf "UAbstract%s%s" (Camel .Module.Name) (Camel .Interface.Name) }}
{{- $Iface := printf "%s%s" $ModuleName $IfaceName }}
{{- $ifaceId := printf "%s.%s" .Module.Name .Interface.Name}}

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "Generated/OLink/{{$Iface}}OLinkClient.h"
#include "ApiGearSettings.h"
#include "ApiGearOLink.h"
#include "Async/Async.h"
#include "Generated/api/{{$ModuleName}}.json.adapter.h"
{{- range .Module.Imports }}
#include "{{Camel .Name}}/Private/Generated/api/{{Camel .Name}}.json.adapter.h"
{{- end }}
#include "OLinkClientConnection.h"
#include "OLinkSink.h"
#include "Engine/Engine.h"
#include "ApiGear/Public/ApiGearConnectionsStore.h"
#include "Misc/DateTime.h"
#include "{{$ModuleName}}Settings.h"
THIRD_PARTY_INCLUDES_START
#include "olink/clientnode.h"
#include "olink/iobjectsink.h"
THIRD_PARTY_INCLUDES_END

{{- if len .Interface.Properties }}
    {{- $shouldIncludeAtomic := 0 -}}
    {{- $shouldIncludeMutex := 0 -}}
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	{{- $shouldIncludeAtomic = 1}}
	{{- else}}
	{{- $shouldIncludeMutex = 1}}
	{{- end}}
{{- end}}
{{- if (eq $shouldIncludeAtomic  1) }}
#include <atomic>
{{- end}}
{{- if (eq $shouldIncludeMutex 1) }}
#include "HAL/CriticalSection.h"
{{- end}}

/**
   \brief data structure to hold the last sent property values
*/
struct {{$Iface}}PropertiesData
{
{{- range $i, $e := .Interface.Properties }}
	{{- if ( ueIsStdSimpleType . ) }}
	std::atomic<{{ueReturn "" .}}> {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- else }}
	FCriticalSection {{ueVar "" .}}Mutex;
	{{ueReturn "" .}} {{ueVar "" .}}{ {{- ueDefault "" . -}} };
	{{- end }}
{{- end }}
};
{{- end }}
DEFINE_LOG_CATEGORY(Log{{$Iface}}OLinkClient);
{{ if .Interface.Description }}
/**
   \brief {{.Interface.Description}}
*/
{{- end }}
{{$Class}}::{{$Class}}()
	: {{$abstractclass}}()
{{- if len .Interface.Properties }}
#if (ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION < 27)
	, _SentData(MakeUnique<{{$Iface}}PropertiesData>())
#else
	, _SentData(MakePimpl<{{$Iface}}PropertiesData>())
#endif
{{- end }}
{
	m_sink = std::make_shared<FOLinkSink>("{{$ifaceId}}");
}

{{$Class}}::{{$Class}}(FVTableHelper& Helper)
	: Super(Helper)
{
}
{{$Class}}::~{{$Class}}() = default;

void {{$Class}}::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);

	m_sink->setOnInitCallback([this]()
		{
		_SubscriptionStatusChanged.Broadcast(true);
	});
	m_sink->setOnReleaseCallback([this]()
		{
		_SubscriptionStatusChanged.Broadcast(false);
	});

	FOLinkSink::FPropertyChangedFunc PropertyChangedFunc = [this](const nlohmann::json& props)
	{
		this->applyState(props);
	};
	m_sink->setOnPropertyChangedCallback(PropertyChangedFunc);

	FOLinkSink::FSignalEmittedFunc SignalEmittedFunc = [this](const std::string& signalName, const nlohmann::json& args)
	{
		this->emitSignal(signalName, args);
	};
	m_sink->setOnSignalEmittedCallback(SignalEmittedFunc);

	check(GEngine);
	U{{$ModuleName}}Settings* settings = GetMutableDefault<U{{$ModuleName}}Settings>();

	UApiGearConnectionsStore* AGCM = GEngine->GetEngineSubsystem<UApiGearConnectionsStore>();

	TScriptInterface<IApiGearConnection> OLinkConnection = AGCM->GetConnection(settings->OLinkConnectionIdentifier);

	if (!OLinkConnection.GetInterface())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Warning, TEXT("No valid olink connection for the %s client, please set in the ApiGear {{ $ModuleName }} plugin settings or during run time"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));
		return;
	}
	UseConnection(OLinkConnection);
	OLinkConnection->Connect();
}

void {{$Class}}::Deinitialize()
{
	// tell the sink that we are gone and should not try to be invoked
	m_sink->resetOnPropertyChangedCallback();
	m_sink->resetOnSignalEmittedCallback();
	m_sink->resetOnInitCallback();
	m_sink->resetOnReleaseCallback();

	if (Connection.GetObject())
	{
		UOLinkClientConnection* UnrealOLinkConnection = Cast<UOLinkClientConnection>(Connection.GetObject());
		UnrealOLinkConnection->unlinkObjectSource(m_sink->olinkObjectName());
		UnrealOLinkConnection->node()->registry().removeSink(m_sink->olinkObjectName());
	}

	Super::Deinitialize();
}

void {{$Class}}::UseConnection(TScriptInterface<IApiGearConnection> InConnection)
{
	checkf(InConnection.GetInterface() != nullptr, TEXT("Cannot use connection - interface IApiGearConnection is not fully implemented"));

	// only accept connections of type olink
	checkf(InConnection->GetConnectionProtocolIdentifier() == ApiGearOLinkProtocolIdentifier, TEXT("Cannot use connection - must be of type olink"));

	UOLinkClientConnection* UnrealOLinkConnection = nullptr;
	// remove old connection
	if (Connection.GetObject())
	{
		UnrealOLinkConnection = Cast<UOLinkClientConnection>(Connection.GetObject());
		UnrealOLinkConnection->unlinkObjectSource(m_sink->olinkObjectName());
		UnrealOLinkConnection->node()->registry().removeSink(m_sink->olinkObjectName());
		UnrealOLinkConnection = nullptr;
	}

	// set up new connection
	UnrealOLinkConnection = Cast<UOLinkClientConnection>(InConnection.GetObject());
	UnrealOLinkConnection->node()->registry().addSink(m_sink);
	UnrealOLinkConnection->linkObjectSource(m_sink->olinkObjectName());

	Connection = InConnection;
}

{{- if len .Interface.Properties }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
{{ueReturn "" .}} {{$Class}}::Get{{Camel .Name}}_Implementation() const
{
	return {{ueVar "" .}};
}

{{- if not .IsReadOnly }}{{nl}}
void {{$Class}}::Set{{Camel .Name}}_Implementation({{ueParam "In" .}})
{
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Warning, TEXT("%s has no node"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (Get{{Camel .Name}}_Implementation() == {{ueVar "In" .}})
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
{{- if not ( ueIsStdSimpleType . )}}
	{
		FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
		if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
		{
			return;
		}
	}
{{- else}}
	if (_SentData->{{ueVar "" .}} == {{ueVar "In" .}})
	{
		return;
	}
{{- end }}
	static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");
	m_sink->GetNode()->setRemoteProperty(memberId, {{ueVar "In" .}});
{{- if not ( ueIsStdSimpleType . ) }}
	FScopeLock Lock(&(_SentData->{{ueVar "" .}}Mutex));
{{- end }}
	_SentData->{{ueVar "" .}} = {{ueVar "In" .}};
}
{{- end }}
{{- end }}
{{- if len .Interface.Operations }}{{ nl }}{{ end }}
{{- range $i, $e := .Interface.Operations }}
{{- if $i }}{{nl}}{{ end }}
{{- if .Description }}
/**
   \brief {{.Description}}
*/
{{- end }}
{{- $returnVal := (ueReturn "" .Return)}}
{{$returnVal}} {{$Class}}::{{Camel .Name}}_Implementation({{ueParams "" .Params}})
{
	{{- if .Return.IsVoid }}
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Warning, TEXT("%s has no node"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));

		return;
	}
	ApiGear::ObjectLink::InvokeReplyFunc Get{{$IfaceName}}StateFunc = [this](ApiGear::ObjectLink::InvokeReplyArg arg) {};
	static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");
	m_sink->GetNode()->invokeRemote(memberId, { {{- ueVars "" .Params -}} }, Get{{$IfaceName}}StateFunc);
	{{- else }}
	if (!m_sink->IsReady())
	{
		UE_LOG(Log{{$Iface}}OLinkClient, Warning, TEXT("%s has no node"), UTF8_TO_TCHAR(m_sink->olinkObjectName().c_str()));

		return {{ ueDefault "" .Return }};
	}
	TPromise<{{$returnVal}}> Promise;
	Async(EAsyncExecution::ThreadPool,
		[{{ueVars "" .Params }}{{if len .Params}}, {{ end }}&Promise, this]()
		{
		ApiGear::ObjectLink::InvokeReplyFunc Get{{$IfaceName}}StateFunc = [&Promise](ApiGear::ObjectLink::InvokeReplyArg arg)
		{
			{{- if not .Return.IsArray}}
			if (!arg.value.empty())
			{
				Promise.SetValue(arg.value.get<{{$returnVal}}>());
			}
			else
			{
				UE_LOG(Log{{$Iface}}OLinkClient, Error, TEXT("{{Camel .Name}}: OLink service returned empty value - should have returned type of {{$returnVal}}"));
				Promise.SetValue({{$returnVal}}());
			}
			{{- else}}
			Promise.SetValue(arg.value.get<{{$returnVal}}>());
			{{- end }}
		};
		static const auto memberId = ApiGear::ObjectLink::Name::createMemberId(m_sink->olinkObjectName(), "{{.Name}}");
		m_sink->GetNode()->invokeRemote(memberId, { {{- ueVars "" .Params -}} }, Get{{$IfaceName}}StateFunc);
	});

	return Promise.GetFuture().Get();
	{{- end }}
}
{{- end }}

bool {{$Class}}::_IsSubscribed() const
{
	return m_sink->IsReady();
}

void {{$Class}}::applyState(const nlohmann::json& fields)
{
{{- range $i, $e := .Interface.Properties }}
{{- if $i }}{{nl}}{{ end }}
	const bool b{{Camel .Name}}Changed = fields.contains("{{.Name}}") && ({{ueVar "" .}} != fields["{{.Name}}"].get<{{ueReturn "" .}}>());
	if (b{{Camel .Name}}Changed)
	{
		{{ueVar "" .}} = fields["{{.Name}}"].get<{{ueReturn "" .}}>();
		Execute__GetSignals(this)->Broadcast{{Camel .Name}}Changed({{ueVar "" .}});
	}
{{- end }}
}

void {{$Class}}::emitSignal(const std::string& signalName, const nlohmann::json& args)
{
{{- range $i, $e := .Interface.Signals }}
{{- if $i }}{{nl}}{{ end }}
	if (signalName == "{{.Name}}")
	{
		{{- range $idx, $elem := .Params }}
		{{ueParam "out" .}} = args[{{$idx}}].get<{{ueReturn "" .}}>();
		{{- end }}
		Execute__GetSignals(this)->Broadcast{{Camel .Name}}Signal({{ueVars "out" .Params}});
		return;
	}
{{- end }}
}
