/**
Copyright 2021 ApiGear UG
Copyright 2021 Epic Games, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

////////////////////////////////
// WARNING AUTOGENERATED
// DO NOT MODIFY
///////////////////////////////

#include "TbRefInterfaces/Generated/MsgBus/TbRefInterfacesParentIfMsgBusClient.h"
#include "TbRefInterfaces/Generated/MsgBus/TbRefInterfacesParentIfMsgBusMessages.h"
#include "Async/Async.h"
#include "Engine/World.h"
#include "Misc/DateTime.h"
#include "GenericPlatform/GenericPlatformMath.h"
#include "GenericPlatform/GenericPlatformTime.h"
#include "MessageEndpointBuilder.h"
#include "MessageEndpoint.h"
#include "TbRefInterfacesSettings.h"
#include "HAL/CriticalSection.h"

/**
   \brief data structure to hold the last sent property values
*/
struct TbRefInterfacesParentIfPropertiesMsgBusData
{
	FCriticalSection LocalIfMutex;
	TScriptInterface<ITbRefInterfacesSimpleLocalIf> LocalIf{TScriptInterface<ITbRefInterfacesSimpleLocalIf>()};
	FCriticalSection ImportedIfMutex;
	TScriptInterface<ITbRefInterfacesImportCounter> ImportedIf{TScriptInterface<ITbRefInterfacesImportCounter>()};
};
DEFINE_LOG_CATEGORY(LogTbRefInterfacesParentIfMsgBusClient);

UTbRefInterfacesParentIfMsgBusClient::UTbRefInterfacesParentIfMsgBusClient()
	: UAbstractTbRefInterfacesParentIf()
	, _SentData(MakePimpl<TbRefInterfacesParentIfPropertiesMsgBusData>())
{
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
}

UTbRefInterfacesParentIfMsgBusClient::~UTbRefInterfacesParentIfMsgBusClient() = default;

void UTbRefInterfacesParentIfMsgBusClient::Initialize(FSubsystemCollectionBase& Collection)
{
	Super::Initialize(Collection);
}

void UTbRefInterfacesParentIfMsgBusClient::Deinitialize()
{
	_Disconnect();

	Super::Deinitialize();
}

void UTbRefInterfacesParentIfMsgBusClient::_Connect()
{
	if (_IsConnected())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Log, TEXT("Already connected, cannot connect again."));
		return;
	}

	if (!_HeartbeatTickerHandle.IsValid())
	{
		UTbRefInterfacesSettings* settings = GetMutableDefault<UTbRefInterfacesSettings>();
		check(settings);
		_HeartbeatIntervalMS = settings->MsgBusHeartbeatIntervalMS;

#if (ENGINE_MAJOR_VERSION < 5)
		FTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
		_HeartbeatTickerHandle = FTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateUObject(this, &UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeatTick), _HeartbeatIntervalMS / 1000.0f);
#else
		FTSTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
		_HeartbeatTickerHandle = FTSTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateUObject(this, &UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeatTick), _HeartbeatIntervalMS / 1000.0f);
#endif
	}

	if (TbRefInterfacesParentIfMsgBusEndpoint.IsValid() && !ServiceAddress.IsValid())
	{
		_DiscoverService();
		return;
	}

	// clang-format off
	TbRefInterfacesParentIfMsgBusEndpoint = FMessageEndpoint::Builder("ApiGear/TbRefInterfaces/ParentIf/Client")
		.Handling<FTbRefInterfacesParentIfInitMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnConnectionInit)
		.Handling<FTbRefInterfacesParentIfPongMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnPong)
		.Handling<FTbRefInterfacesParentIfServiceDisconnectMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnServiceClosedConnection)
		.Handling<FTbRefInterfacesParentIfLocalIfSignalSignalMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnLocalIfSignal)
		.Handling<FTbRefInterfacesParentIfImportedIfSignalSignalMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnImportedIfSignal)
		.Handling<FTbRefInterfacesParentIfLocalIfChangedMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnLocalIfChanged)
		.Handling<FTbRefInterfacesParentIfImportedIfChangedMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnImportedIfChanged)
		.Handling<FTbRefInterfacesParentIfLocalIfMethodReplyMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnLocalIfMethodReply)
		.Handling<FTbRefInterfacesParentIfImportedIfMethodReplyMessage>(this, &UTbRefInterfacesParentIfMsgBusClient::OnImportedIfMethodReply)
		.Build();
	// clang-format on

	_DiscoverService();
}

void UTbRefInterfacesParentIfMsgBusClient::_Disconnect()
{
	_LastHbTimestamp = 0.0f;

#if (ENGINE_MAJOR_VERSION < 5)
	FTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
#else
	FTSTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
#endif

	if (!_IsConnected())
	{
		return;
	}

	auto msg = new FTbRefInterfacesParentIfClientDisconnectMessage();

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfClientDisconnectMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	TbRefInterfacesParentIfMsgBusEndpoint.Reset();
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
	_ConnectionStatusChangedBP.Broadcast(false);
}

void UTbRefInterfacesParentIfMsgBusClient::_DiscoverService()
{
	if (!TbRefInterfacesParentIfMsgBusEndpoint.IsValid())
	{
		return;
	}

	auto msg = new FTbRefInterfacesParentIfDiscoveryMessage();
	TbRefInterfacesParentIfMsgBusEndpoint->Publish<FTbRefInterfacesParentIfDiscoveryMessage>(msg);
}

bool UTbRefInterfacesParentIfMsgBusClient::_IsConnected() const
{
	return TbRefInterfacesParentIfMsgBusEndpoint.IsValid() && ServiceAddress.IsValid();
}

void UTbRefInterfacesParentIfMsgBusClient::OnConnectionInit(const FTbRefInterfacesParentIfInitMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress.IsValid())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Warning,
			TEXT("Got a second init message. It usually means that there are several instances of the same service on the network.")
				TEXT(" This can cause connection mixups. Please make sure that there is only one instance of the service running on the network."));
		return;
	}

	ServiceAddress = Context->GetSender();
	// reset ping stats for a new connection
	PingRTTBuffer.Empty();
	PingRTTBuffer.SetNumZeroed(PING_RTT_BUFFER_SIZE);
	CurrentPingCounter = 0;
	Stats.CurrentRTT_MS = 0.0f;
	Stats.AverageRTT_MS = 0.0f;
	Stats.MaxRTT_MS = 0.0f;
	Stats.MinRTT_MS = 10000.0f;

	const bool b_ClientPingIntervalMSChanged = InMessage._ClientPingIntervalMS != _HeartbeatIntervalMS;
	if (b_ClientPingIntervalMSChanged)
	{
		_HeartbeatIntervalMS = InMessage._ClientPingIntervalMS;

#if (ENGINE_MAJOR_VERSION < 5)
		FTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
		_HeartbeatTickerHandle = FTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateUObject(this, &UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeatTick), _HeartbeatIntervalMS / 1000.0f);
#else
		FTSTicker::GetCoreTicker().RemoveTicker(_HeartbeatTickerHandle);
		_HeartbeatTickerHandle = FTSTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateUObject(this, &UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeatTick), _HeartbeatIntervalMS / 1000.0f);
#endif
	}
	const bool bLocalIfChanged = InMessage.LocalIf != LocalIf;
	if (bLocalIfChanged)
	{
		LocalIf = InMessage.LocalIf;
		// reset sent data to the current state
		{
			FScopeLock Lock(&(_SentData->LocalIfMutex));
			_SentData->LocalIf = LocalIf;
		}
		_GetSignals()->BroadcastLocalIfChanged(LocalIf);
	}

	const bool bImportedIfChanged = InMessage.ImportedIf != ImportedIf;
	if (bImportedIfChanged)
	{
		ImportedIf = InMessage.ImportedIf;
		// reset sent data to the current state
		{
			FScopeLock Lock(&(_SentData->ImportedIfMutex));
			_SentData->ImportedIf = ImportedIf;
		}
		_GetSignals()->BroadcastImportedIfChanged(ImportedIf);
	}

	_ConnectionStatusChanged.Broadcast(true);
	_ConnectionStatusChangedBP.Broadcast(true);
}

bool UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeatTick(float /*DeltaTime*/)
{
	_OnHeartbeat();
	return true;
}

void UTbRefInterfacesParentIfMsgBusClient::_OnHeartbeat()
{
	if (_LastHbTimestamp > 0.1)
	{
		const double DeltaMS = (FPlatformTime::Seconds() - _LastHbTimestamp) * 1000.0;

		if (DeltaMS > 2 * _HeartbeatIntervalMS)
		{
			// service seems to be dead or not responding - reset connection
			ServiceAddress.Invalidate();
			_LastHbTimestamp = 0.0;
			_ConnectionStatusChanged.Broadcast(false);
		}
	}

	if (!_IsConnected())
	{
		// only log warning message once a second
		if (FPlatformTime::Seconds() - _LastConnectionWarningTimestamp > 1.0)
		{
			UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Warning, TEXT("Heartbeat failed. Client has no connection to service. Reconnecting ..."));
			_LastConnectionWarningTimestamp = FPlatformTime::Seconds();
		}

		_Connect();
		return;
	}

	auto msg = new FTbRefInterfacesParentIfPingMessage();
	msg->Timestamp = FPlatformTime::Seconds();

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfPingMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
}

float UTbRefInterfacesParentIfMsgBusClient::_CalculateAverageRTT() const
{
	if (CurrentPingCounter == 0)
	{
		return 0.0f;
	}

	float TotalRTT = 0.0f;

	for (const float& RTT : PingRTTBuffer)
	{
		TotalRTT += RTT;
	}

	return CurrentPingCounter > 0 ? TotalRTT / CurrentPingCounter : 0.0f;
}

void UTbRefInterfacesParentIfMsgBusClient::OnPong(const FTbRefInterfacesParentIfPongMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	_LastHbTimestamp = InMessage.Timestamp;

	const double Current = FPlatformTime::Seconds();
	const double DeltaMS = (Current - InMessage.Timestamp) * 1000.0f;

	Stats.CurrentRTT_MS = DeltaMS;
	if (CurrentPingCounter < PING_RTT_BUFFER_SIZE)
	{
		CurrentPingCounter++;
	}
	PingRTTBuffer.RemoveAt(0);
	PingRTTBuffer.Add(Stats.CurrentRTT_MS);
	Stats.AverageRTT_MS = _CalculateAverageRTT();
	Stats.MaxRTT_MS = FGenericPlatformMath::Max(Stats.MaxRTT_MS, Stats.CurrentRTT_MS);
	Stats.MinRTT_MS = FGenericPlatformMath::Min(Stats.MinRTT_MS, Stats.CurrentRTT_MS);

	_StatsUpdated.Broadcast(Stats);
}

const FTbRefInterfacesParentIfStats& UTbRefInterfacesParentIfMsgBusClient::_GetStats() const
{
	return Stats;
}

void UTbRefInterfacesParentIfMsgBusClient::OnServiceClosedConnection(const FTbRefInterfacesParentIfServiceDisconnectMessage& /*InMessage*/, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		return;
	}

	_LastHbTimestamp = 0.0;
	ServiceAddress.Invalidate();
	_ConnectionStatusChanged.Broadcast(false);
	_ConnectionStatusChangedBP.Broadcast(false);
}

TScriptInterface<ITbRefInterfacesSimpleLocalIf> UTbRefInterfacesParentIfMsgBusClient::GetLocalIf() const
{
	return LocalIf;
}

void UTbRefInterfacesParentIfMsgBusClient::SetLocalIf(const TScriptInterface<ITbRefInterfacesSimpleLocalIf>& InLocalIf)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetLocalIf() == InLocalIf)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->LocalIfMutex));
		if (_SentData->LocalIf == InLocalIf)
		{
			return;
		}
	}

	auto msg = new FTbRefInterfacesParentIfSetLocalIfRequestMessage();
	msg->LocalIf = InLocalIf;

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfSetLocalIfRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->LocalIfMutex));
	_SentData->LocalIf = InLocalIf;
}

TScriptInterface<ITbRefInterfacesImportCounter> UTbRefInterfacesParentIfMsgBusClient::GetImportedIf() const
{
	return ImportedIf;
}

void UTbRefInterfacesParentIfMsgBusClient::SetImportedIf(const TScriptInterface<ITbRefInterfacesImportCounter>& InImportedIf)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Client has no connection to service."));
		return;
	}

	// only send change requests if the value changed -> reduce network load
	if (GetImportedIf() == InImportedIf)
	{
		return;
	}

	// only send change requests if the value wasn't already sent -> reduce network load
	{
		FScopeLock Lock(&(_SentData->ImportedIfMutex));
		if (_SentData->ImportedIf == InImportedIf)
		{
			return;
		}
	}

	auto msg = new FTbRefInterfacesParentIfSetImportedIfRequestMessage();
	msg->ImportedIf = InImportedIf;

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfSetImportedIfRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());
	FScopeLock Lock(&(_SentData->ImportedIfMutex));
	_SentData->ImportedIf = InImportedIf;
}

TScriptInterface<ITbRefInterfacesSimpleLocalIf> UTbRefInterfacesParentIfMsgBusClient::LocalIfMethod(const TScriptInterface<ITbRefInterfacesSimpleLocalIf>& InParam)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TScriptInterface<ITbRefInterfacesSimpleLocalIf>();
	}

	auto msg = new FTbRefInterfacesParentIfLocalIfMethodRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->Param = InParam;
	TPromise<TScriptInterface<ITbRefInterfacesSimpleLocalIf>> Promise;
	StorePromise(msg->ResponseId, Promise);

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfLocalIfMethodRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTbRefInterfacesParentIfMsgBusClient::OnLocalIfMethodReply(const FTbRefInterfacesParentIfLocalIfMethodReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

TScriptInterface<ITbRefInterfacesImportCounter> UTbRefInterfacesParentIfMsgBusClient::ImportedIfMethod(const TScriptInterface<ITbRefInterfacesImportCounter>& InParam)
{
	if (!_IsConnected())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Client has no connection to service."));

		return TScriptInterface<ITbRefInterfacesImportCounter>();
	}

	auto msg = new FTbRefInterfacesParentIfImportedIfMethodRequestMessage();
	msg->ResponseId = FGuid::NewGuid();
	msg->Param = InParam;
	TPromise<TScriptInterface<ITbRefInterfacesImportCounter>> Promise;
	StorePromise(msg->ResponseId, Promise);

	TbRefInterfacesParentIfMsgBusEndpoint->Send<FTbRefInterfacesParentIfImportedIfMethodRequestMessage>(msg, EMessageFlags::Reliable,
		nullptr,
		TArrayBuilder<FMessageAddress>().Add(ServiceAddress),
		FTimespan::Zero(),
		FDateTime::MaxValue());

	return Promise.GetFuture().Get();
}

void UTbRefInterfacesParentIfMsgBusClient::OnImportedIfMethodReply(const FTbRefInterfacesParentIfImportedIfMethodReplyMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	FulfillPromise(InMessage.ResponseId, InMessage.Result);
}

void UTbRefInterfacesParentIfMsgBusClient::OnLocalIfSignal(const FTbRefInterfacesParentIfLocalIfSignalSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastLocalIfSignalSignal(InMessage.Param);
	return;
}

void UTbRefInterfacesParentIfMsgBusClient::OnImportedIfSignal(const FTbRefInterfacesParentIfImportedIfSignalSignalMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	_GetSignals()->BroadcastImportedIfSignalSignal(InMessage.Param);
	return;
}

void UTbRefInterfacesParentIfMsgBusClient::OnLocalIfChanged(const FTbRefInterfacesParentIfLocalIfChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bLocalIfChanged = InMessage.LocalIf != LocalIf;
	if (bLocalIfChanged)
	{
		LocalIf = InMessage.LocalIf;
		// reset sent data to the current state
		{
			FScopeLock Lock(&(_SentData->LocalIfMutex));
			_SentData->LocalIf = LocalIf;
		}
		_GetSignals()->BroadcastLocalIfChanged(LocalIf);
	}
}

void UTbRefInterfacesParentIfMsgBusClient::OnImportedIfChanged(const FTbRefInterfacesParentIfImportedIfChangedMessage& InMessage, const TSharedRef<IMessageContext, ESPMode::ThreadSafe>& Context)
{
	if (ServiceAddress != Context->GetSender())
	{
		UE_LOG(LogTbRefInterfacesParentIfMsgBusClient, Error, TEXT("Got a message from wrong service(%s) instead of %s"), *Context->GetSender().ToString(), *ServiceAddress.ToString());
		return;
	}

	const bool bImportedIfChanged = InMessage.ImportedIf != ImportedIf;
	if (bImportedIfChanged)
	{
		ImportedIf = InMessage.ImportedIf;
		// reset sent data to the current state
		{
			FScopeLock Lock(&(_SentData->ImportedIfMutex));
			_SentData->ImportedIf = ImportedIf;
		}
		_GetSignals()->BroadcastImportedIfChanged(ImportedIf);
	}
}

template <typename ResultType>
bool UTbRefInterfacesParentIfMsgBusClient::StorePromise(const FGuid& Id, TPromise<ResultType>& Promise)
{
	FScopeLock Lock(&ReplyPromisesMapCS);
	return ReplyPromisesMap.Add(Id, &Promise) != nullptr;
}

template <typename ResultType>
bool UTbRefInterfacesParentIfMsgBusClient::FulfillPromise(const FGuid& Id, const ResultType& Value)
{
	TPromise<ResultType>* PromisePtr = nullptr;

	{
		FScopeLock Lock(&ReplyPromisesMapCS);
		if (auto** Found = ReplyPromisesMap.Find(Id))
		{
			PromisePtr = static_cast<TPromise<ResultType>*>(*Found);
			ReplyPromisesMap.Remove(Id);
		}
	}

	if (PromisePtr)
	{
		PromisePtr->SetValue(Value);
		return true;
	}
	return false;
}

template bool UTbRefInterfacesParentIfMsgBusClient::StorePromise<TScriptInterface<ITbRefInterfacesImportCounter>>(const FGuid& Id, TPromise<TScriptInterface<ITbRefInterfacesImportCounter>>& Promise);
template bool UTbRefInterfacesParentIfMsgBusClient::FulfillPromise<TScriptInterface<ITbRefInterfacesImportCounter>>(const FGuid& Id, const TScriptInterface<ITbRefInterfacesImportCounter>& Value);
template bool UTbRefInterfacesParentIfMsgBusClient::StorePromise<TScriptInterface<ITbRefInterfacesSimpleLocalIf>>(const FGuid& Id, TPromise<TScriptInterface<ITbRefInterfacesSimpleLocalIf>>& Promise);
template bool UTbRefInterfacesParentIfMsgBusClient::FulfillPromise<TScriptInterface<ITbRefInterfacesSimpleLocalIf>>(const FGuid& Id, const TScriptInterface<ITbRefInterfacesSimpleLocalIf>& Value);
